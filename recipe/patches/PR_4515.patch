From 1ae41a4f7f73ad432284b70b0cd1e255e4558b62 Mon Sep 17 00:00:00 2001
From: Mikhail Brinskiy <mikhailb@mellanox.com>
Date: Tue, 8 Oct 2019 21:05:21 +0300
Subject: [PATCH 1/3] Merge pull request #4137 from
 ssaulters/topic/cuda-ipc-cvd

UCT/CUDA: CUDA_VISIBLE_DEVICES support.
---
 src/uct/cuda/cuda_ipc/cuda_ipc_cache.c |   8 +-
 src/uct/cuda/cuda_ipc/cuda_ipc_iface.c |   8 +-
 src/uct/cuda/cuda_ipc/cuda_ipc_md.c    | 204 +++++++++++++++++++++----
 src/uct/cuda/cuda_ipc/cuda_ipc_md.h    |  26 +++-
 4 files changed, 208 insertions(+), 38 deletions(-)

diff --git a/src/uct/cuda/cuda_ipc/cuda_ipc_cache.c b/src/uct/cuda/cuda_ipc/cuda_ipc_cache.c
index e7079a53f4..0adef70165 100644
--- a/src/uct/cuda/cuda_ipc/cuda_ipc_cache.c
+++ b/src/uct/cuda/cuda_ipc/cuda_ipc_cache.c
@@ -137,11 +137,17 @@ ucs_status_t uct_cuda_ipc_cache_map_memhandle(void *arg, uct_cuda_ipc_key_t *key
             /* close memhandle */
             UCT_CUDADRV_FUNC(cuIpcCloseMemHandle((CUdeviceptr)
                                                  region->mapped_addr));
+            key->d_mapped = 0;
             ucs_free(region);
         }
     }
 
-    status = uct_cuda_ipc_open_memhandle(key->ph, (CUdeviceptr *)mapped_addr);
+    status = (key->d_mapped == 0) /* potentially already opened in rkey_unpack */
+           ? uct_cuda_ipc_open_memhandle(key->ph, &key->d_mapped)
+           : UCS_OK;
+
+    *mapped_addr = (void *)key->d_mapped;
+
     if (ucs_unlikely(status != UCS_OK)) {
         if (ucs_likely(status == UCS_ERR_ALREADY_EXISTS)) {
             /* unmap all overlapping regions and retry*/
diff --git a/src/uct/cuda/cuda_ipc/cuda_ipc_iface.c b/src/uct/cuda/cuda_ipc/cuda_ipc_iface.c
index 271a17773e..70389b95f9 100644
--- a/src/uct/cuda/cuda_ipc/cuda_ipc_iface.c
+++ b/src/uct/cuda/cuda_ipc/cuda_ipc_iface.c
@@ -346,6 +346,12 @@ static ucs_mpool_ops_t uct_cuda_ipc_event_desc_mpool_ops = {
 ucs_status_t uct_cuda_ipc_map_memhandle(void *arg, uct_cuda_ipc_key_t *key,
                                         void **mapped_addr)
 {
+    if (key->d_mapped != 0) {
+        /* potentially already mapped in uct_cuda_ipc_rkey_unpack */
+        *mapped_addr = (void *) key->d_mapped;
+        return UCS_OK;
+    }
+
     return  UCT_CUDADRV_FUNC(cuIpcOpenMemHandle((CUdeviceptr *)mapped_addr,
                              key->ph, CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS));
 }
@@ -441,6 +447,6 @@ UCS_CLASS_DEFINE_NEW_FUNC(uct_cuda_ipc_iface_t, uct_iface_t, uct_md_h, uct_worke
                           const uct_iface_params_t*, const uct_iface_config_t*);
 static UCS_CLASS_DEFINE_DELETE_FUNC(uct_cuda_ipc_iface_t, uct_iface_t);
 
-UCT_TL_DEFINE(&uct_cuda_ipc_component, cuda_ipc, uct_cuda_base_query_devices,
+UCT_TL_DEFINE(&uct_cuda_ipc_component.super, cuda_ipc, uct_cuda_base_query_devices,
               uct_cuda_ipc_iface_t, "CUDA_IPC_", uct_cuda_ipc_iface_config_table,
               uct_cuda_ipc_iface_config_t);
diff --git a/src/uct/cuda/cuda_ipc/cuda_ipc_md.c b/src/uct/cuda/cuda_ipc/cuda_ipc_md.c
index d7d6bd5ffa..d7b79b9f9b 100644
--- a/src/uct/cuda/cuda_ipc/cuda_ipc_md.c
+++ b/src/uct/cuda/cuda_ipc/cuda_ipc_md.c
@@ -15,7 +15,6 @@
 #include <sys/types.h>
 #include <unistd.h>
 
-
 static ucs_config_field_t uct_cuda_ipc_md_config_table[] = {
     {"", "", NULL,
      ucs_offsetof(uct_cuda_ipc_md_config_t, super), UCS_CONFIG_TYPE_TABLE(uct_md_config_table)},
@@ -45,27 +44,119 @@ static ucs_status_t uct_cuda_ipc_mkey_pack(uct_md_h md, uct_mem_h memh,
     uct_cuda_ipc_key_t *packed   = (uct_cuda_ipc_key_t *) rkey_buffer;
     uct_cuda_ipc_key_t *mem_hndl = (uct_cuda_ipc_key_t *) memh;
 
-    *packed = *mem_hndl;
+    *packed          = *mem_hndl;
+    packed->d_mapped = 0;
+
+    return cuDeviceGetUuid(&packed->uuid, mem_hndl->dev_num) == CUDA_SUCCESS
+           ? UCS_OK : UCS_ERR_IO_ERROR;
+}
+
+static inline int uct_cuda_ipc_uuid_equals(const CUuuid* a, const CUuuid* b)
+{
+    int64_t *a0 = (int64_t *) a->bytes;
+    int64_t *b0 = (int64_t *) b->bytes;
+    return (a0[0] == b0[0]) && (a0[1] == b0[1]) ? 1 : 0;
+}
+
+static inline void uct_cuda_ipc_uuid_copy(CUuuid* dst, const CUuuid* src)
+{
+    int64_t *a = (int64_t *) src->bytes;
+    int64_t *b = (int64_t *) dst->bytes;
+    *b++ = *a++;
+    *b   = *a;
+}
+
+static ucs_status_t uct_cuda_ipc_get_unique_index_for_uuid(int* idx,
+                                                           uct_cuda_ipc_md_t* md,
+                                                           CUuuid* uuid)
+{
+    int i;
+
+    for (i = 0; i < md->uuid_map_size; i++) {
+        if (uct_cuda_ipc_uuid_equals(uuid, &md->uuid_map[i])) {
+            *idx = i;
+            return UCS_OK; /* found */
+        }
+    }
+
+    if (ucs_unlikely(md->uuid_map_size == md->uuid_map_capacity)) {
+        /* reallocate on demand */
+        int num_devices;
+        int original_cache_size, new_cache_size;
+        int new_capacity = md->uuid_map_capacity * 2;
+
+        UCT_CUDA_IPC_DEVICE_GET_COUNT(num_devices);
+        original_cache_size   = md->uuid_map_capacity * num_devices;
+        new_cache_size        = new_capacity * num_devices;
+        md->uuid_map_capacity = new_capacity;
+        md->uuid_map          = ucs_realloc(md->uuid_map,
+                                            new_capacity * sizeof(CUuuid),
+                                            "uct_cuda_ipc_uuid_map");
+        if (md->uuid_map == NULL) {
+            return UCS_ERR_NO_MEMORY;
+        }
+
+        md->peer_accessible_cache = ucs_realloc(md->peer_accessible_cache,
+                                                new_cache_size,
+                                                "uct_cuda_ipc_peer_accessible_cache");
+        if (md->peer_accessible_cache == NULL) {
+            return UCS_ERR_NO_MEMORY;
+        }
+
+        memset(md->peer_accessible_cache + original_cache_size, 0xFF,
+               new_cache_size - original_cache_size);
+    }
+
+    /* Add new mapping */
+    uct_cuda_ipc_uuid_copy(&md->uuid_map[md->uuid_map_size], uuid);
+    *idx = md->uuid_map_size++;
 
     return UCS_OK;
 }
 
+static ucs_status_t uct_cuda_ipc_is_peer_accessible(uct_cuda_ipc_component_t *mdc,
+                                                    uct_cuda_ipc_key_t *rkey)
+{
+    CUdevice this_device;
+    ucs_status_t status;
+    int peer_idx;
+    int num_devices;
+    char* accessible;
+
+    status = uct_cuda_ipc_get_unique_index_for_uuid(&peer_idx, mdc->md, &rkey->uuid);
+    if (ucs_unlikely(status != UCS_OK)) {
+        return status;
+    }
+
+    UCT_CUDA_IPC_GET_DEVICE(this_device);
+    UCT_CUDA_IPC_DEVICE_GET_COUNT(num_devices);
+
+    accessible = &mdc->md->peer_accessible_cache[peer_idx * num_devices + this_device];
+    if (*accessible == -1) { /* unchecked, add to cache */
+        /* rkey->d_mapped is picked up in uct_cuda_ipc_cache_map_memhandle */
+        CUresult result = cuIpcOpenMemHandle(&rkey->d_mapped,
+                                             rkey->ph,
+                                             CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS);
+        *accessible = ((result != CUDA_SUCCESS) && (result != CUDA_ERROR_ALREADY_MAPPED))
+                    ? 0 : 1;
+    }
+
+    return (*accessible == 1) ? UCS_OK : UCS_ERR_UNREACHABLE;
+}
+
 static ucs_status_t uct_cuda_ipc_rkey_unpack(uct_component_t *component,
                                              const void *rkey_buffer,
                                              uct_rkey_t *rkey_p, void **handle_p)
 {
-    uct_cuda_ipc_key_t *packed = (uct_cuda_ipc_key_t *) rkey_buffer;
+    uct_cuda_ipc_component_t *com = ucs_derived_of(component, uct_cuda_ipc_component_t);
+    uct_cuda_ipc_key_t *packed    = (uct_cuda_ipc_key_t *) rkey_buffer;
     uct_cuda_ipc_key_t *key;
     ucs_status_t status;
-    CUdevice cu_device;
-    int peer_accessble;
 
-    UCT_CUDA_IPC_GET_DEVICE(cu_device);
+    status = uct_cuda_ipc_is_peer_accessible(com, packed);
 
-    status = UCT_CUDADRV_FUNC(cuDeviceCanAccessPeer(&peer_accessble,
-                                                    cu_device, packed->dev_num));
-    if ((status != UCS_OK) || (peer_accessble == 0)) {
-        return UCS_ERR_UNREACHABLE;
+    if (status != UCS_OK) {
+        return status;
     }
 
     key = ucs_malloc(sizeof(uct_cuda_ipc_key_t), "uct_cuda_ipc_key_t");
@@ -111,6 +202,7 @@ uct_cuda_ipc_mem_reg_internal(uct_md_h uct_md, void *addr, size_t length,
                                           &(key->b_len),
                                           (CUdeviceptr) addr));
     key->dev_num  = (int) cu_device;
+    key->d_mapped = 0;
     ucs_trace("registered memory:%p..%p length:%lu dev_num:%d",
               addr, addr + length, length, (int) cu_device);
     return UCS_OK;
@@ -142,43 +234,91 @@ static ucs_status_t uct_cuda_ipc_mem_dereg(uct_md_h md, uct_mem_h memh)
     return UCS_OK;
 }
 
+
+static void uct_cuda_ipc_md_close(uct_md_h uct_md)
+{
+    uct_cuda_ipc_md_t *md = ucs_derived_of(uct_md, uct_cuda_ipc_md_t);
+
+    ucs_free(md->uuid_map);
+    ucs_free(md->peer_accessible_cache);
+    ucs_free(md);
+}
+
 static ucs_status_t
 uct_cuda_ipc_md_open(uct_component_t *component, const char *md_name,
                      const uct_md_config_t *config, uct_md_h *md_p)
 {
     static uct_md_ops_t md_ops = {
-        .close              = (void*)ucs_empty_function,
+        .close              = uct_cuda_ipc_md_close,
         .query              = uct_cuda_ipc_md_query,
         .mkey_pack          = uct_cuda_ipc_mkey_pack,
         .mem_reg            = uct_cuda_ipc_mem_reg,
         .mem_dereg          = uct_cuda_ipc_mem_dereg,
         .detect_memory_type = ucs_empty_function_return_unsupported,
     };
-    static uct_md_t md = {
-        .ops          = &md_ops,
-        .component    = &uct_cuda_ipc_component
-    };
 
-    *md_p = &md;
+    int num_devices;
+    uct_cuda_ipc_md_t* md;
+    uct_cuda_ipc_component_t* com;
+
+    UCS_STATIC_ASSERT(sizeof(md->peer_accessible_cache[0]) == sizeof(char));
+    UCT_CUDA_IPC_DEVICE_GET_COUNT(num_devices);
+
+    md = ucs_calloc(1, sizeof(uct_cuda_ipc_md_t), "uct_cuda_ipc_md");
+    if (md == NULL) {
+        return UCS_ERR_NO_MEMORY;
+    }
+
+    md->super.ops       = &md_ops;
+    md->super.component = &uct_cuda_ipc_component.super;
+
+    /* allocate uuid map and peer accessible cache */
+    md->uuid_map_size     = 0;
+    md->uuid_map_capacity = 16;
+    md->uuid_map          = ucs_malloc(md->uuid_map_capacity * sizeof(CUuuid),
+                                       "uct_cuda_ipc_uuid_map");
+    if (md->uuid_map == NULL) {
+        free(md);
+        return UCS_ERR_NO_MEMORY;
+    }
+
+    /* Initially support caching accessibility of up to 16 other peers */
+    md->peer_accessible_cache = ucs_malloc(num_devices * md->uuid_map_capacity,
+                                           "uct_cuda_ipc_peer_accessible_cache");
+    if (md->peer_accessible_cache == NULL) {
+        free(md->uuid_map);
+        free(md);
+        return UCS_ERR_NO_MEMORY;
+    }
+
+    /* 0xFF = !cached, 1 = accessible, 0 = !accessible */
+    memset(md->peer_accessible_cache, 0xFF, num_devices * md->uuid_map_capacity);
+
+    com     = ucs_derived_of(md->super.component, uct_cuda_ipc_component_t);
+    com->md = md;
+    *md_p   = &md->super;
     return UCS_OK;
 }
 
-uct_component_t uct_cuda_ipc_component = {
-    .query_md_resources = uct_cuda_base_query_md_resources,
-    .md_open            = uct_cuda_ipc_md_open,
-    .cm_open            = ucs_empty_function_return_unsupported,
-    .rkey_unpack        = uct_cuda_ipc_rkey_unpack,
-    .rkey_ptr           = ucs_empty_function_return_unsupported,
-    .rkey_release       = uct_cuda_ipc_rkey_release,
-    .name               = "cuda_ipc",
-    .md_config          = {
-        .name           = "Cuda-IPC memory domain",
-        .prefix         = "CUDA_IPC_",
-        .table          = uct_cuda_ipc_md_config_table,
-        .size           = sizeof(uct_cuda_ipc_md_config_t),
+uct_cuda_ipc_component_t uct_cuda_ipc_component = {
+    .super = {
+        .query_md_resources = uct_cuda_base_query_md_resources,
+        .md_open            = uct_cuda_ipc_md_open,
+        .cm_open            = ucs_empty_function_return_unsupported,
+        .rkey_unpack        = uct_cuda_ipc_rkey_unpack,
+        .rkey_ptr           = ucs_empty_function_return_unsupported,
+        .rkey_release       = uct_cuda_ipc_rkey_release,
+        .name               = "cuda_ipc",
+        .md_config          = {
+            .name           = "Cuda-IPC memory domain",
+            .prefix         = "CUDA_IPC_",
+            .table          = uct_cuda_ipc_md_config_table,
+            .size           = sizeof(uct_cuda_ipc_md_config_t),
+        },
+        .tl_list            = UCT_COMPONENT_TL_LIST_INITIALIZER(&uct_cuda_ipc_component.super),
+        .flags              = 0
     },
-    .tl_list            = UCT_COMPONENT_TL_LIST_INITIALIZER(&uct_cuda_ipc_component),
-    .flags              = 0
+    .md                     = NULL,
 };
-UCT_COMPONENT_REGISTER(&uct_cuda_ipc_component);
+UCT_COMPONENT_REGISTER(&uct_cuda_ipc_component.super);
 
diff --git a/src/uct/cuda/cuda_ipc/cuda_ipc_md.h b/src/uct/cuda/cuda_ipc/cuda_ipc_md.h
index bca2430eb4..cb26a410cc 100644
--- a/src/uct/cuda/cuda_ipc/cuda_ipc_md.h
+++ b/src/uct/cuda/cuda_ipc/cuda_ipc_md.h
@@ -14,17 +14,26 @@
 
 #define UCT_CUDA_IPC_MAX_ALLOC_SZ (1 << 30)
 
-
-extern uct_component_t uct_cuda_ipc_component;
-
-
 /**
  * @brief cuda ipc MD descriptor
  */
 typedef struct uct_cuda_ipc_md {
     struct uct_md super;   /**< Domain info */
+    CUuuid*       uuid_map;
+    char*         peer_accessible_cache;
+    int           uuid_map_size;
+    int           uuid_map_capacity;
 } uct_cuda_ipc_md_t;
 
+/**
+ * @brief cuda ipc component extension
+ */
+typedef struct uct_cuda_ipc_component {
+    uct_component_t    super;
+    uct_cuda_ipc_md_t* md;
+} uct_cuda_ipc_component_t;
+
+extern uct_cuda_ipc_component_t uct_cuda_ipc_component;
 
 /**
  * @brief cuda ipc domain configuration.
@@ -42,6 +51,8 @@ typedef struct uct_cuda_ipc_key {
     CUdeviceptr    d_bptr;       /* Allocation base address */
     size_t         b_len;        /* Allocation size */
     int            dev_num;      /* GPU Device number */
+    CUuuid         uuid;         /* GPU Device UUID */
+    CUdeviceptr    d_mapped;     /* Locally mapped device address */
 } uct_cuda_ipc_key_t;
 
 
@@ -52,4 +63,11 @@ typedef struct uct_cuda_ipc_key {
         }                                                               \
     } while(0);
 
+#define UCT_CUDA_IPC_DEVICE_GET_COUNT(_num_device)                        \
+    do {                                                                  \
+        if (UCS_OK != UCT_CUDADRV_FUNC(cuDeviceGetCount(&_num_device))) { \
+            return UCS_ERR_IO_ERROR;                                      \
+        }                                                                 \
+    } while(0);
+
 #endif

From f8bc1dd618cd974d6090baf7422f525f47c0f9ba Mon Sep 17 00:00:00 2001
From: Yossi Itigin <yosefe@mellanox.com>
Date: Sat, 2 Nov 2019 14:32:13 +0200
Subject: [PATCH 2/3] Merge pull request #4366 from bureddy/fix-cuda_ipc

UCT/CUDA_IPC: Fix peer_accessible check
---
 src/uct/cuda/cuda_ipc/cuda_ipc_md.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/uct/cuda/cuda_ipc/cuda_ipc_md.c b/src/uct/cuda/cuda_ipc/cuda_ipc_md.c
index d7b79b9f9b..68bdeb54c2 100644
--- a/src/uct/cuda/cuda_ipc/cuda_ipc_md.c
+++ b/src/uct/cuda/cuda_ipc/cuda_ipc_md.c
@@ -132,7 +132,7 @@ static ucs_status_t uct_cuda_ipc_is_peer_accessible(uct_cuda_ipc_component_t *md
     UCT_CUDA_IPC_DEVICE_GET_COUNT(num_devices);
 
     accessible = &mdc->md->peer_accessible_cache[peer_idx * num_devices + this_device];
-    if (*accessible == -1) { /* unchecked, add to cache */
+    if (*accessible == (char)0xFF) { /* unchecked, add to cache */
         /* rkey->d_mapped is picked up in uct_cuda_ipc_cache_map_memhandle */
         CUresult result = cuIpcOpenMemHandle(&rkey->d_mapped,
                                              rkey->ph,

From c8eb74cd07eb67c54aabb8a1424a3f8bcc2d5a07 Mon Sep 17 00:00:00 2001
From: Yossi Itigin <yosefe@mellanox.com>
Date: Wed, 27 Nov 2019 16:55:42 +0200
Subject: [PATCH 3/3] Merge pull request #4476 from
 Akshay-Venkatesh/topic/cuda-ipc-fix-reg-limit

UCT/CUDA/CUDA_IPC: Use ULONG_MAX for registration limit
---
 Makefile.am                                |  1 +
 contrib/test_jenkins.sh                    | 22 ++++++++++++++++++++++
 contrib/ucx_perftest_config/msg_pow2_large | 10 ++++++++++
 src/tools/perf/Makefile.am                 |  1 +
 src/uct/cuda/cuda_ipc/cuda_ipc_iface.c     |  4 ++--
 src/uct/cuda/cuda_ipc/cuda_ipc_md.c        |  2 +-
 src/uct/cuda/cuda_ipc/cuda_ipc_md.h        |  2 --
 7 files changed, 37 insertions(+), 5 deletions(-)
 create mode 100644 contrib/ucx_perftest_config/msg_pow2_large

diff --git a/Makefile.am b/Makefile.am
index 23af1b30dd..6f57ec1a22 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -21,6 +21,7 @@ doc_dir = $(pkgdatadir)/doc
 if !DOCS_ONLY
 perftest_dir = $(pkgdatadir)/perftest
 dist_perftest__DATA = contrib/ucx_perftest_config/msg_pow2 \
+					  contrib/ucx_perftest_config/msg_pow2_large \
 					  contrib/ucx_perftest_config/README \
 					  contrib/ucx_perftest_config/test_types_uct \
 					  contrib/ucx_perftest_config/test_types_ucp \
diff --git a/contrib/test_jenkins.sh b/contrib/test_jenkins.sh
index dd8cd90ba8..a5a7ccdf2b 100755
--- a/contrib/test_jenkins.sh
+++ b/contrib/test_jenkins.sh
@@ -872,6 +872,28 @@ run_ucx_perftest() {
 			run_client_server_app "$ucx_perftest" "$ucp_test_args" "$(hostname)" 0 0
 		fi
 
+		# Specifically test cuda_ipc for large message sizes
+	        cat $ucx_inst_ptest/test_types_ucp | grep -v cuda | sort -R > $ucx_inst_ptest/test_types_cuda_ucp
+		ucp_test_args_large="-b $ucx_inst_ptest/test_types_cuda_ucp \
+			             -b $ucx_inst_ptest/msg_pow2_large -w 1"
+		if [ $with_mpi -eq 1 ]
+		then
+			for ipc_cache in y n
+			do
+				$MPIRUN -np 2 -x UCX_TLS=self,sm,cuda_copy,cuda_ipc \
+					-x UCX_CUDA_IPC_CACHE=$ipc_cache $AFFINITY $ucx_perftest $ucp_test_args_large
+			done
+		else
+			for ipc_cache in y n
+			do
+				export UCX_TLS=self,sm,cuda_copy,cuda_ipc
+				export UCX_CUDA_IPC_CACHE=$ipc_cache
+				run_client_server_app "$ucx_perftest" "$ucp_test_args_large" "$(hostname)" 0 0
+				unset UCX_TLS
+				unset UCX_CUDA_IPC_CACHE
+			done
+		fi
+
 		unset CUDA_VISIBLE_DEVICES
 	fi
 }
diff --git a/contrib/ucx_perftest_config/msg_pow2_large b/contrib/ucx_perftest_config/msg_pow2_large
new file mode 100644
index 0000000000..114dba8b51
--- /dev/null
+++ b/contrib/ucx_perftest_config/msg_pow2_large
@@ -0,0 +1,10 @@
+4194304    -s 4194304    -n 100
+8388608    -s 8388608    -n 100
+16777216   -s 16777216   -n 100
+33554432   -s 33554432   -n 100
+67108864   -s 67108864   -n 10
+134217728  -s 134217728  -n 10
+268435456  -s 268435456  -n 10
+536870912  -s 536870912  -n 10
+1073741824 -s 1073741824 -n 10
+2147483648 -s 2147483648 -n 10
diff --git a/src/tools/perf/Makefile.am b/src/tools/perf/Makefile.am
index 5cd2153802..9365b2cd51 100644
--- a/src/tools/perf/Makefile.am
+++ b/src/tools/perf/Makefile.am
@@ -26,6 +26,7 @@ ucx_perftest_LDADD    = \
 perftestdir = $(pkgdatadir)/perftest
 dist_perftest_DATA = \
 	$(top_srcdir)/contrib/ucx_perftest_config/msg_pow2 \
+	$(top_srcdir)/contrib/ucx_perftest_config/msg_pow2_large \
 	$(top_srcdir)/contrib/ucx_perftest_config/README \
 	$(top_srcdir)/contrib/ucx_perftest_config/test_types_uct \
 	$(top_srcdir)/contrib/ucx_perftest_config/test_types_ucp \
diff --git a/src/uct/cuda/cuda_ipc/cuda_ipc_iface.c b/src/uct/cuda/cuda_ipc/cuda_ipc_iface.c
index 70389b95f9..cdc8c24c7e 100644
--- a/src/uct/cuda/cuda_ipc/cuda_ipc_iface.c
+++ b/src/uct/cuda/cuda_ipc/cuda_ipc_iface.c
@@ -89,14 +89,14 @@ static ucs_status_t uct_cuda_ipc_iface_query(uct_iface_h tl_iface,
     iface_attr->cap.put.max_short       = 0;
     iface_attr->cap.put.max_bcopy       = 0;
     iface_attr->cap.put.min_zcopy       = 0;
-    iface_attr->cap.put.max_zcopy       = UCT_CUDA_IPC_MAX_ALLOC_SZ;
+    iface_attr->cap.put.max_zcopy       = ULONG_MAX;
     iface_attr->cap.put.opt_zcopy_align = 1;
     iface_attr->cap.put.align_mtu       = iface_attr->cap.put.opt_zcopy_align;
     iface_attr->cap.put.max_iov         = 1;
 
     iface_attr->cap.get.max_bcopy       = 0;
     iface_attr->cap.get.min_zcopy       = 0;
-    iface_attr->cap.get.max_zcopy       = UCT_CUDA_IPC_MAX_ALLOC_SZ;
+    iface_attr->cap.get.max_zcopy       = ULONG_MAX;
     iface_attr->cap.get.opt_zcopy_align = 1;
     iface_attr->cap.get.align_mtu       = iface_attr->cap.get.opt_zcopy_align;
     iface_attr->cap.get.max_iov         = 1;
diff --git a/src/uct/cuda/cuda_ipc/cuda_ipc_md.c b/src/uct/cuda/cuda_ipc/cuda_ipc_md.c
index 68bdeb54c2..576877f431 100644
--- a/src/uct/cuda/cuda_ipc/cuda_ipc_md.c
+++ b/src/uct/cuda/cuda_ipc/cuda_ipc_md.c
@@ -30,7 +30,7 @@ static ucs_status_t uct_cuda_ipc_md_query(uct_md_h md, uct_md_attr_t *md_attr)
     md_attr->cap.access_mem_type  = UCS_MEMORY_TYPE_CUDA;
     md_attr->cap.detect_mem_types = 0;
     md_attr->cap.max_alloc        = 0;
-    md_attr->cap.max_reg          = UCT_CUDA_IPC_MAX_ALLOC_SZ;
+    md_attr->cap.max_reg          = ULONG_MAX;
     md_attr->rkey_packed_size     = sizeof(uct_cuda_ipc_key_t);
     md_attr->reg_cost.overhead    = 0;
     md_attr->reg_cost.growth      = 0;
diff --git a/src/uct/cuda/cuda_ipc/cuda_ipc_md.h b/src/uct/cuda/cuda_ipc/cuda_ipc_md.h
index cb26a410cc..02bb944c77 100644
--- a/src/uct/cuda/cuda_ipc/cuda_ipc_md.h
+++ b/src/uct/cuda/cuda_ipc/cuda_ipc_md.h
@@ -12,8 +12,6 @@
 #include <uct/cuda/base/cuda_iface.h>
 
 
-#define UCT_CUDA_IPC_MAX_ALLOC_SZ (1 << 30)
-
 /**
  * @brief cuda ipc MD descriptor
  */
